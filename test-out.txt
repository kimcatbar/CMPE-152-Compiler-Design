PROGRAM: program
INDENTIFIER: mergearrays
SEMICOLON: ;
PROCEDURE: procedure
INDENTIFIER: merge
LPAREN: (
VAR: var
INDENTIFIER: ar1
COMMA: ,
INDENTIFIER: ar2
COMMA: ,
INDENTIFIER: ar3
COLON: :
ARRAY: array
OF: of
INDENTIFIER: integer
SEMICOLON: ;
VAR: var
INDENTIFIER: y
COMMA: ,
INDENTIFIER: z
COLON: :
INDENTIFIER: integer
RPAREN: )
SEMICOLON: ;
VAR: var
INDENTIFIER: l
COMMA: ,
INDENTIFIER: m
COMMA: ,
INDENTIFIER: n
COLON: :
INDENTIFIER: integer
SEMICOLON: ;
BEGIN: begin
INDENTIFIER: l
ASSIGN: :=
: 
INTEGER: 0
SEMICOLON: ;
INDENTIFIER: m
ASSIGN: :=
: 
INTEGER: 0
SEMICOLON: ;
INDENTIFIER: n
ASSIGN: :=
: 
INTEGER: 0
SEMICOLON: ;
WHILE: while
LPAREN: (
LPAREN: (
INDENTIFIER: l
LT: <
INDENTIFIER: y
RPAREN: )
AND: and
LPAREN: (
INDENTIFIER: m
LT: <
INDENTIFIER: z
RPAREN: )
RPAREN: )
DO: do
BEGIN: begin
IF: if
LPAREN: (
INDENTIFIER: ar1
LBRACKET: [
INDENTIFIER: l
RBRACKET: ]
LT: <
INDENTIFIER: ar2
LBRACKET: [
INDENTIFIER: m
RBRACKET: ]
RPAREN: )
THEN: then
BEGIN: begin
INDENTIFIER: ar3
LBRACKET: [
INDENTIFIER: n
RBRACKET: ]
ASSIGN: :=
: 
INDENTIFIER: ar1
LBRACKET: [
INDENTIFIER: l
RBRACKET: ]
SEMICOLON: ;
INDENTIFIER: l
ASSIGN: :=
: 
INDENTIFIER: l
PLUSOP: +
INTEGER: 1
SEMICOLON: ;
INDENTIFIER: n
ASSIGN: :=
: 
INDENTIFIER: n
PLUSOP: +
INTEGER: 1
SEMICOLON: ;
END: end
SEMICOLON: ;
IF: if
LPAREN: (
INDENTIFIER: ar1
LBRACKET: [
INDENTIFIER: l
RBRACKET: ]
GTEQ: >=
INDENTIFIER: ar2
LBRACKET: [
INDENTIFIER: m
RBRACKET: ]
RPAREN: )
THEN: then
BEGIN: begin
INDENTIFIER: ar3
LBRACKET: [
INDENTIFIER: n
RBRACKET: ]
ASSIGN: :=
: 
INDENTIFIER: ar2
LBRACKET: [
INDENTIFIER: m
RBRACKET: ]
SEMICOLON: ;
INDENTIFIER: m
ASSIGN: :=
: 
INDENTIFIER: m
PLUSOP: +
INTEGER: 1
SEMICOLON: ;
INDENTIFIER: n
ASSIGN: :=
: 
INDENTIFIER: n
PLUSOP: +
INTEGER: 1
SEMICOLON: ;
END: end
SEMICOLON: ;
END: end
SEMICOLON: ;
WHILE: while
LPAREN: (
INDENTIFIER: l
LT: <
INDENTIFIER: y
RPAREN: )
DO: do
BEGIN: begin
INDENTIFIER: ar3
LBRACKET: [
INDENTIFIER: n
RBRACKET: ]
ASSIGN: :=
: 
INDENTIFIER: ar1
LBRACKET: [
INDENTIFIER: l
RBRACKET: ]
SEMICOLON: ;
INDENTIFIER: l
ASSIGN: :=
: 
INDENTIFIER: l
PLUSOP: +
INTEGER: 1
SEMICOLON: ;
INDENTIFIER: n
ASSIGN: :=
: 
INDENTIFIER: n
PLUSOP: +
INTEGER: 1
SEMICOLON: ;
END: end
SEMICOLON: ;
WHILE: while
LPAREN: (
INDENTIFIER: m
LT: <
INDENTIFIER: z
RPAREN: )
DO: do
BEGIN: begin
INDENTIFIER: ar3
LBRACKET: [
INDENTIFIER: n
RBRACKET: ]
ASSIGN: :=
: 
INDENTIFIER: ar2
LBRACKET: [
INDENTIFIER: m
RBRACKET: ]
SEMICOLON: ;
INDENTIFIER: m
ASSIGN: :=
: 
INDENTIFIER: m
PLUSOP: +
INTEGER: 1
SEMICOLON: ;
INDENTIFIER: n
ASSIGN: :=
: 
INDENTIFIER: n
PLUSOP: +
INTEGER: 1
SEMICOLON: ;
END: end
SEMICOLON: ;
END: end
SEMICOLON: ;
PROCEDURE: procedure
INDENTIFIER: printarray
LPAREN: (
VAR: var
INDENTIFIER: a
COLON: :
ARRAY: array
OF: of
INDENTIFIER: integer
SEMICOLON: ;
VAR: var
INDENTIFIER: z
COLON: :
INDENTIFIER: integer
RPAREN: )
SEMICOLON: ;
VAR: var
INDENTIFIER: x
COLON: :
INDENTIFIER: integer
SEMICOLON: ;
BEGIN: begin
FOR: for
INDENTIFIER: x
ASSIGN: :=
: 
INTEGER: 0
TO: to
INDENTIFIER: z
MINUSOP: -
INTEGER: 2
DO: do
BEGIN: begin
END: end
SEMICOLON: ;
INDENTIFIER: writeln
LPAREN: (
RPAREN: )
SEMICOLON: ;
END: end
SEMICOLON: ;
VAR: var
INDENTIFIER: a1
COLON: :
ARRAY: array
LBRACKET: [
REAL: 1..20
RBRACKET: ]
OF: of
INDENTIFIER: integer
SEMICOLON: ;
LBRACE: {
: st
ARRAY: array
INTEGER: 1
RBRACE: }
INDENTIFIER: a2
COLON: :
ARRAY: array
LBRACKET: [
REAL: 1..20
RBRACKET: ]
OF: of
INDENTIFIER: integer
SEMICOLON: ;
LBRACE: {
: nd
ARRAY: array
INTEGER: 2
RBRACE: }
INDENTIFIER: a3
COLON: :
ARRAY: array
LBRACKET: [
REAL: 1..40
RBRACKET: ]
OF: of
INDENTIFIER: integer
SEMICOLON: ;
LBRACE: {
: rd
ARRAY: array
TO: to
: combine
: st
INTEGER: 31
: nd
INTEGER: 2
RBRACE: }
INDENTIFIER: s1
COMMA: ,
INDENTIFIER: s2
COMMA: ,
INDENTIFIER: s3
COMMA: ,
INDENTIFIER: i
COLON: :
INDENTIFIER: integer
SEMICOLON: ;
LBRACE: {
: s1
FOR: for
INDENTIFIER: a1
COMMA: ,
: s2
FOR: for
INDENTIFIER: a2
COMMA: ,
: s3
EQUAL: =
: si
AND: and
: s2
COMMA: ,
: i
EQUAL: =
ARRAY: array
INDENTIFIER: index
RBRACE: }
LBRACE: {
INDENTIFIER: main
LPAREN: (
RPAREN: )
FUNCTION: function
TO: to
: populate
ARRAY: array
RBRACE: }
BEGIN: begin
: i
ASSIGN: :=
: 
INTEGER: 1
SEMICOLON: ;
LBRACE: {
: index
FOR: for
INDENTIFIER: a1
RBRACE: }
INDENTIFIER: read
LPAREN: (
INDENTIFIER: a1
LBRACKET: [
: i
RBRACKET: ]
RPAREN: )
SEMICOLON: ;
LBRACE: {
: read
: data
: directly
: at
: index
: s1
RBRACE: }
WHILE: while
NOT: not
: eoln
DO: do
BEGIN: begin
: i
ASSIGN: :=
: 
: i
PLUSOP: +
INTEGER: 1
SEMICOLON: ;
: read
LPAREN: (
INDENTIFIER: a1
LBRACKET: [
: i
RBRACKET: ]
RPAREN: )
SEMICOLON: ;
END: end
SEMICOLON: ;
: s1
ASSIGN: :=
: 
: i
SEMICOLON: ;
: i
ASSIGN: :=
: 
INTEGER: 1
SEMICOLON: ;
: read
LPAREN: (
INDENTIFIER: a2
LBRACKET: [
: i
RBRACKET: ]
RPAREN: )
SEMICOLON: ;
WHILE: while
NOT: not
: eoln
DO: do
BEGIN: begin
: i
ASSIGN: :=
: 
: i
PLUSOP: +
INTEGER: 1
SEMICOLON: ;
: read
LPAREN: (
INDENTIFIER: a2
LBRACKET: [
: i
RBRACKET: ]
RPAREN: )
SEMICOLON: ;
END: end
SEMICOLON: ;
: s2
ASSIGN: :=
: 
: i
SEMICOLON: ;
INDENTIFIER: printarray
LPAREN: (
INDENTIFIER: a1
COMMA: ,
: s1
RPAREN: )
SEMICOLON: ;
INDENTIFIER: printarray
LPAREN: (
INDENTIFIER: a2
COMMA: ,
: s2
RPAREN: )
SEMICOLON: ;
: s3
ASSIGN: :=
: 
: s1
PLUSOP: +
: s2
SEMICOLON: ;
INDENTIFIER: merge
LPAREN: (
INDENTIFIER: a1
COMMA: ,
INDENTIFIER: a2
COMMA: ,
INDENTIFIER: a3
COMMA: ,
: s1
COMMA: ,
: s2
RPAREN: )
SEMICOLON: ;
INDENTIFIER: printarray
LPAREN: (
INDENTIFIER: a3
COMMA: ,
: s3
RPAREN: )
SEMICOLON: ;
: end.
